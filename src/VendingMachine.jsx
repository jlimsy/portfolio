import * as THREE from "three";
import { useThree } from "@react-three/fiber";
import { useTexture } from "@react-three/drei";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { projectsArray } from "./utils/projects";
import colors from "./utils/colors";

export function VendingMachine(props) {
  const { scene, nodes, materials } = useGLTF(
    `${import.meta.env.BASE_URL}vending_machine.glb`
  );

  const { handleOpenDialog, handleOpenAboutMe } = props;

  let screenMeshCount = 0;

  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI, 0, -Math.PI]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Coin.geometry}
          material={materials.Black}
          position={[-0.408, 0.045, -0.428]}
          rotation={[-Math.PI / 2, 0, 0]}
        />
        <group position={[0, -0.915, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube005.geometry}
            material={materials.Main}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube005_1.geometry}
            material={materials.Black}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube005_2.geometry}
            material={materials.Main}
          />
        </group>
        {Object.entries(nodes).map(([key, node]) => {
          if (!node.geometry || !key.includes("Row")) return null;

          console.log(key.includes("Row"), key);

          const index = parseInt(key.slice(3, 5)) - 1;
          console.log("index", index);

          const material =
            index >= projectsArray.length
              ? node.material
              : new THREE.MeshBasicMaterial({ color: colors[index] });

          return (
            <mesh
              key={key}
              geometry={node.geometry}
              material={material}
              // material={node.material}
              position={node.position}
              rotation={node.rotation}
              scale={node.scale}
              castShadow
              receiveShadow
            />
          );
        })}
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009.geometry}
          material={materials.Main}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_1.geometry}
          material={materials.Glass}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_2.geometry}
          material={materials.Base}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_3.geometry}
          material={materials.Black}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_4.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_5.geometry}
          material={materials.Metal}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube009_6.geometry}
          material={materials.About}
          onClick={handleOpenAboutMe}
        />
        {Object.entries(nodes).map(([key, node]) => {
          if (!node.geometry || !node.material.name.includes("Screen"))
            return null;

          const index = screenMeshCount;
          screenMeshCount += 1;

          const material =
            index >= projectsArray.length
              ? node.material
              : new THREE.MeshBasicMaterial({ color: colors[index] });

          return (
            <mesh
              key={key}
              geometry={node.geometry}
              material={material}
              // material={node.material}
              userData={{ index, projectName: projectsArray[index] }}
              castShadow
              receiveShadow
              onClick={(event) => {
                event.stopPropagation();
                const mesh = event.object;
                handleOpenDialog(mesh.userData.projectName);
              }}
            />
          );
        })}
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen001_1.geometry}
          material={materials.Shelves}
        />

        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen002_1.geometry}
          material={materials.Shelves}
        />

        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen003_1.geometry}
          material={materials.Shelves}
        />

        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen004_1.geometry}
          material={materials.Shelves}
        />

        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen005_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen006_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen007_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen008_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen009_1.geometry}
          material={materials.Plate}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen010_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen011_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen012_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen013_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen014_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen015_1.geometry}
          material={materials.Shelves}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Screen016_1.geometry}
          material={materials.Shelves}
        />
      </group>
    </group>
  );
}

useGLTF.preload(`${import.meta.env.BASE_URL}vending_machine.glb`);
